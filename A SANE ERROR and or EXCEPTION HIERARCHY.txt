A SANE ERROR and/or EXCEPTION HIERARCHY
For C++ and any other language for that matter.
High-level description of the logical aspects, not the eaxact mapping between the abstract concept and language mechanisms(s).

Several significantly different conditions and events regarding program execution correctness and reliability:
Expected error conditions:
- (SSE) Strictly synchronous errors : ones which are the direct consequence of an operation being performed, or one which has just been performed per se but has not been finalized from the programmer's point of view (e.g. integer division by 0). Modern out-of-order hardware may and often does impose some obscurity on strict synchronicity, so very fine-grained guarantees are not possible everywhere. Strictly synchronous errors may sometimes be reported to the program by things like OS signals, which aren't exactly 100% synchronous and don't appear as such, but usually function acceptably (E.g. the CPU will normally not visibly execute anything after a faulting arithmetic instruction but will immediately trap into the OS interrupt/signal handling subsystem).
- (CRE) Context-related but possibly unpredictable and delayed errors : things like network transfers which fail in the middle, or in general any semi-asynchronous events, usually I/O related or concurrency-related. These will also inevitably be a somewhat fuzzy category due to the variety of real-world hardware, system software, networks, and the general complexity of interactions between among them and with the "real world". This includes issues like a user not providing timely input, too.
- (SFE) Spurious errors which are not clearly attributable to a program-level operation/request/state. Hardware dying or impending power loss is normally such an error, but concurrency deadlock or lack/disruption of network connectivity isn't.

It is considered that, in general, the first 2 kinds of error conditions are to be expected to some degree by the programmer and architect, so they are subject to handling for most serious programs. The third kind of error conditions is considered of a truly exceptional nature - for most programs, such conditions are considered beyond the scope of reasonable design precautions and are treated as unfortunate happenings beyond anyone's control. For most programs it's OK to just die then, and perhaps rely on some system daemon to restart them (of course, if the system isn't completely dead or locked up itself).
Taking those considerations into account, it makes a lot of sense to have SSEs implemented as some kind of error codes or error objects returned via normal control flow mechanisms, and to force compiler checks (if possible in the respective language/runtime) to make sure they are not simply ignored by the programmer and architect. They must also be lightweight. CREs should be treated similarly, but perhaps exception-style implementations like C++ or Java exceptions are better. For SFEs, it makes no sense to have have return codes or force any language-level checking but rather to just throw an exception or directly kill the program. In high-reliability contexts, it may be necessary to at least attemot some handling, e.g. put the system into a failsafe mode, rather than just crash.

So, perhaps classification could be taken a bit further:
- Errors : conditions which are usually correctable at least partially and are likely to occur, often quite predictable in terms of program location and interactions with the OS/hardware/network/real world. Errors are required to be treated by the programmer and not simply ignored. Errors are part of normal execution and are treated as (part of) a possible return value of a subroutine or even a simple arithmetic operation. They are usually handled locally, and escalated to higher levels of the program only if/when needed.
- Exceptions : conditions which are, well, exceptional. They are hard to predict, beyond the scope of normal program operation, severe violations of normal operation, and are unfixable or not worth fixing most of the time, and are to be handled only when/if the system architect desires so. They should put the entire application into an emergency state; they are a global thing rather a local concern. In high-reliability applications they will require handling, in "normal" applications the application is smply allowed to die with a message.

- Warnings : In some cases it may be desirable to have a condition to let the runtime and application logic denote and communicate potentially bad conditions, or at least ones which are suspicious. Therefore, a third class of conditions is worth creating. Warnings must not intrude on the normal program flow, but rather convey information to the users/clients of an application that there might be something wrong. They are expected to be logged somewhere, and might cause the runtime and possibly business logic modules to perform additional checks further on. It should in general be up to the architect and programmer to handle warnings, and to request (or not) additional checks (e.g. some sort of debug mode). Warnings may not have an equivalent in popular languages and mapping them to other constructs may be difficult.

In general, it seems that the notion of execution mode/ execution correctness and safety level should be made a first-class concept, and be modelled and manipulated as a (simple) finite state machine. There's nothing completely wrong with individual error and exception-handling constructs and mechanisms in languages like C, C++, Java - they all work more or less and they are all useful more or less and they all are (in)convenient more or less; the problem is that they are all focused on lower-level mechanics rather than the program or application as a whole and that makes them less useful and flexible than they could be.

